<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <title>JFR Viewier</title>
  <style>
    :root{--bg:#0b1220;--fg:#e9eef5;--acc:#3b82f6;--mut:#96a0b5}
    *{box-sizing:border-box}
    body{margin:0;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);color:var(--fg);min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .grid{display:grid;grid-template-columns:1fr 2fr;gap:16px;width:min(1500px,100%)}
    .panel{background:#0f172a;border:1px solid #223;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.3);padding:18px;min-height:360px}
    h1{margin:0 0 8px;font-size:20px}
    p{margin:0 0 12px;color:var(--mut)}
    .drop{border:2px dashed #334155;border-radius:14px;padding:24px;text-align:center;transition:.15s;user-select:none}
    .drop.highlight{border-color:var(--acc);background:rgba(59,130,246,.08)}
    .btns{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    button,.ghost{padding:10px 14px;border-radius:10px;border:0;background:var(--acc);color:#fff;cursor:pointer}
    .ghost{background:#1f2937;color:var(--fg)}
    ul{list-style:none;padding:0;margin:12px 0 0;max-height:180px;overflow:auto;border-top:1px solid #223}
    li{display:flex;justify-content:space-between;gap:8px;padding:8px 0;border-bottom:1px dashed #223}
    small{color:var(--mut)}
    .row{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:10px}
    progress{width:100%;height:10px}
    .history{border:2px dashed #334155;border-radius:14px;padding:12px;min-height:360px}
    .history ol{margin:8px 0 0;padding-left:0px;max-height:420px;overflow:auto}
    .history li{display:grid;grid-template-columns:12fr 2fr 1fr 1fr;gap:8px;align-items:start}
    .history li a{word-break:break-word;text-decoration:none}
    .history li a:hover{text-decoration:underline}
    .history-name{cursor:text;min-width:0;display:inline-flex;align-items:center;gap:6px}
    .history-name[contenteditable="true"]{outline:1px solid var(--acc);border-radius:4px;padding:0 4px}
  </style>
</head>
<body>
  <div class="grid">
    <section class="panel" aria-label="File upload">
      <h1>File Upload</h1>
      <p>Drag and drop files or select manually. Upload via <code>fetch</code>.</p>

      <input id="fileInput" type="file" name="files" multiple hidden>

      <div id="drop" class="drop" tabindex="0" role="button" aria-label="Drop area for files">
        Drag files here or click
        <div class="btns">
          <button type="button" id="pick" class="ghost">Choose files</button>
          <button type="button" id="send">Send files</button>
        </div>
      </div>
      <label for="addFlamegraph" style="display:flex;gap:8px;align-items:center;justify-content:flex-start;margin-top:10px;color:#cbd5e1;font-size:14px;">
        <input id="addFlamegraph" type="checkbox" style="accent-color:#3b82f6">
        <span style="font-weight:600;">Add flamegraphs</span>
      </label>

      <ul id="list" aria-live="polite"></ul>
      <div class="row"><progress id="prog" max="100" value="0" hidden></progress><span id="status" aria-live="polite"></span></div>
    </section>

    <section class="panel" aria-label="Link history">
      <div class="history">
        <div class="row" style="justify-content:space-between;margin:0 0 6px 0">
          <strong>History</strong>
          <button type="button" id="clear" class="ghost">Clear</button>
        </div>
        <ol id="history"></ol>
      </div>
    </section>
  </div>

  <div id="statsModal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,.5);z-index:9999;align-items:center;justify-content:center;">
    <div style="background:#181e2a;color:#e9eef5;padding:24px;border-radius:12px;max-width:1500px;max-height:80vh;overflow:auto;box-shadow:0 4px 32px #0008;position:relative;">
      <h3 id="statsTitle" style="margin-top:0;word-break:break-all;overflow-wrap:anywhere;display:flex;align-items:center;justify-content:space-between;font-size:15px;">
        <span id="statsUuid"></span>
        <button id="closeStats" style="margin-left:18px;font-size:20px;background:none;border:none;cursor:pointer;z-index:2;color:#e9eef5;line-height:1;padding-right:0px;padding-top:0px;">✖️</button>
      </h3>
      <pre id="statsContent" style="white-space:pre-wrap;word-break:break-all;font-size:13px;"></pre>
    </div>
  </div>

<script>
(() => {
  'use strict';
  // 1) Settings. Set your real endpoint here:
  const UPLOAD_URL = '/api/convertor';
  // 2) Keys in localStorage:
  const LS_KEY = 'htmlLinksHistory';

  // 3) DOM elements:
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const pick = document.getElementById('pick');
  const sendBtn = document.getElementById('send');
  const list = document.getElementById('list');
  const prog = document.getElementById('prog');
  const status = document.getElementById('status');
  const historyEl = document.getElementById('history');
  const clearBtn = document.getElementById('clear');
  const flameCheckbox = document.getElementById('addFlamegraph');
  const STATS_TITLE_MAX = 400;
  const setStatus = (txt = '') => { status.textContent = txt; };
  const resetProgress = () => { prog.hidden = true; prog.value = 0; };
  const stringifyStats = (stats) => {
    try{ return JSON.stringify(stats, null, 2) || ''; }
    catch{ return ''; }
  };
  const trimmedStatsTitle = (stats) => {
    const str = stringifyStats(stats);
    return str.slice(0, STATS_TITLE_MAX) + (str.length > STATS_TITLE_MAX ? '…' : '');
  };
  const createLink = (href, label) => {
    const a = document.createElement('a');
    a.href = href;
    a.target = '_blank';
    a.rel = 'noopener';
    a.textContent = label;
    return a;
  };
  const createIcon = (symbol, color, title, handler) => {
    const span = document.createElement('span');
    span.textContent = symbol;
    span.style.color = color;
    span.style.fontSize = '20px';
    span.style.verticalAlign = 'middle';
    span.style.cursor = 'pointer';
    span.title = title || '';
    span.addEventListener('click', (e) => {
      e.stopPropagation();
      handler?.();
    });
    return span;
  };
  const createLinks = (base, entries) => entries.map(([suffix, label]) => createLink(base + suffix, label));
  const createHistoryNameSpan = (item, statsString) => {
    const nameSpan = document.createElement('span');
    const displayName = (item.name && item.name.trim()) ? item.name.trim() : item.uuid;
    nameSpan.textContent = displayName;
    nameSpan.className = 'history-name';
    nameSpan.dataset.uuid = item.uuid;
    nameSpan.spellcheck = false;
    nameSpan.tabIndex = 0;
    nameSpan.title = statsString;
    nameSpan.addEventListener('dblclick', (e) => {
      e.stopPropagation();
      beginNameEdit(nameSpan);
    });
    nameSpan.addEventListener('keydown', (e) => {
      if(nameSpan.dataset.editing !== '1') return;
      if(e.key === 'Enter'){
        e.preventDefault();
        finishNameEdit(item.uuid, nameSpan, true, {triggerBlur: true});
      } else if(e.key === 'Escape'){
        e.preventDefault();
        finishNameEdit(item.uuid, nameSpan, false, {triggerBlur: true});
      }
    });
    nameSpan.addEventListener('blur', () => {
      finishNameEdit(item.uuid, nameSpan, true);
    });
    return nameSpan;
  };

  // === Link history on the right ===
  function loadHistory(){
    try{
      const raw = JSON.parse(localStorage.getItem(LS_KEY) || '[]');
      if(!Array.isArray(raw)) return [];
      return raw.map(item => {
        if(!item || typeof item !== 'object' || !item.uuid) return null;
        return {
          ...item,
          name: typeof item.name === 'string' ? item.name : '',
          flame: Boolean(item.flame)
        };
      }).filter(Boolean);
    }catch{
      return [];
    }
  }
  function saveHistory(arr){ localStorage.setItem(LS_KEY, JSON.stringify(arr)); }
  function addToHistory(obj){
    if(!obj || !obj.uuid) return;
    const arr = loadHistory();
    const idx = arr.findIndex(x => x.uuid === obj.uuid);
    if(idx !== -1){
      const existing = arr[idx];
      const updated = {
        ...existing,
        ...obj,
        name: existing.name || ''
      };
      arr.splice(idx, 1);
      arr.unshift(updated);
    } else {
      const entry = {
        ...obj,
        name: typeof obj.name === 'string' ? obj.name : '',
        flame: Boolean(obj.flame)
      };
      arr.unshift(entry);
    }
    saveHistory(arr);
    renderHistory();
  }
  function normalizeConvertorPayload(raw){
    const payload = typeof raw === 'string' ? JSON.parse(raw) : raw;
    if(!payload || typeof payload !== 'object') throw new Error('Payload must be an object or JSON string');
    if(!payload.uuid) throw new Error('Payload must include a uuid field');
    return {
      uuid: String(payload.uuid),
      stats: payload.stats,
      flame: Boolean(payload.flame),
      name: typeof payload.name === 'string' ? payload.name : ''
    };
  }
  function applyConvertorResponse(rawPayload, {statusMessage = 'Simulated response applied.'} = {}){
    const normalized = normalizeConvertorPayload(rawPayload);
    addToHistory(normalized);
    setStatus(statusMessage);
    resetProgress();
    return normalized;
  }
  window.applyConvertorResponse = applyConvertorResponse;
  function clearHistory(){ saveHistory([]); renderHistory(); }
  function persistHistoryName(uuid, newName){
    const arr = loadHistory();
    const idx = arr.findIndex(item => item.uuid === uuid);
    if(idx === -1) return;
    arr[idx].name = newName;
    saveHistory(arr);
    renderHistory();
  }
  function placeCaretAtEnd(el){
    const range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
  }
  function beginNameEdit(span){
    if(span.dataset.editing === '1') return;
    span.dataset.editing = '1';
    span.dataset.originalName = span.textContent;
    span.setAttribute('contenteditable', 'true');
    span.focus();
    placeCaretAtEnd(span);
  }
  function finishNameEdit(uuid, span, shouldSave, options = {}){
    if(span.dataset.editing !== '1') return;
    const { triggerBlur = false } = options;
    const original = span.dataset.originalName || '';
    const rawText = span.textContent.replace(/\s+/g, ' ').trim();
    span.dataset.editing = '';
    span.removeAttribute('contenteditable');
    delete span.dataset.originalName;
    if(!shouldSave){
      span.textContent = original;
      if(triggerBlur) span.blur();
      return;
    }
    const displayValue = rawText || uuid;
    const storedValue = displayValue === uuid ? '' : displayValue;
    span.textContent = displayValue;
    if(triggerBlur) span.blur();
    if(displayValue !== original){
      persistHistoryName(uuid, storedValue);
    }
  }
  function renderHistory(){
    const arr = loadHistory();
    historyEl.innerHTML = '';
    if(arr.length === 0){
      const li = document.createElement('li');
      li.textContent = 'No links yet';
      historyEl.append(li);
      return;
    }
    const frag = document.createDocumentFragment();
    arr.forEach(item => {
      const li = document.createElement('li');

      const uuidSpan = document.createElement('span');
      const statsString = trimmedStatsTitle(item.stats);
      uuidSpan.title = statsString;
      uuidSpan.style.fontSize = '16px';
      uuidSpan.style.fontWeight = 'bold';
      uuidSpan.style.display = 'inline-flex';
      uuidSpan.style.alignItems = 'center';
      uuidSpan.style.gap = '4px';

      const infoIcon = createIcon('ⓘ', 'rgb(96, 165, 250)', 'Show statistics', () => {
        showStatsModal(item.stats, 'Statistics', statsString);
      });
      const detailsIcon = createIcon('Ⓓ', 'rgb(96, 165, 250)', 'Show recommendations', async () => {
        try {
          const response = await fetch("/api/detector/" + item.uuid);
          if (!response.ok) throw new Error("HTTP " + response.status);
          showStatsModal(await response.text(), 'Recommendations');
        } catch (err) {
          showStatsModal(err.toString(), 'Recommendations');
          console.error(err);
        }
      });
      detailsIcon.style.paddingRight = '5px';

      const nameSpan = createHistoryNameSpan(item, statsString);
      uuidSpan.append(infoIcon, /*detailsIcon,*/ nameSpan);

      const baseLinks = createLinks('/api/convertor/' + item.uuid, [
        ['', 'heatmap'],
        ['-cpu', 'cpu'],
        ['-alloc', 'alloc']
      ]);
      li.append(uuidSpan, ...baseLinks);

      if(item.flame){
        const sep = document.createElement('span');
        sep.textContent = 'flame graphs ⟶';
        sep.style.color = '#475569';
        const flameLinks = createLinks('/api/convertor/' + item.uuid, [
          ['-flame', 'flamegraph'],
          ['-flame-cpu', 'cpu'],
          ['-flame-alloc', 'alloc']
        ]);
        li.append(sep, ...flameLinks);
      }

      frag.append(li);
    });
    historyEl.append(frag);
  }

  // === File handling on the left ===
  let batchSeq = 0;            // counter for selected file batches
  let lastSelectedBatchId = 0; // id of the last selected batch (what we send)

  // Render: add items to the list (DO NOT clear the list)
  function appendToList(files, batchId){
    const stamp = new Date().toLocaleTimeString();
    [...files].forEach(f => {
      const li = document.createElement('li');
      li.dataset.batch = String(batchId);
      li.title = `Batch #${batchId} · ${stamp}`;
      const name = document.createElement('span');
      const size = document.createElement('small');
      name.textContent = f.name;
      size.textContent = (f.size/1024).toFixed(1) + ' KB';
      li.append(name, size);
      list.append(li);
    });
  }

  // Set CURRENT files (overwrite input), visually — ADD to the end of the list
  function setFiles(files){
    const dt = new DataTransfer();
    [...files].forEach(f => dt.items.add(f));
    fileInput.files = dt.files; // only current batch in input
    lastSelectedBatchId = ++batchSeq;
    appendToList(files, lastSelectedBatchId);
  }

  // Delayed removal of a specific batch after 10 seconds
  function scheduleBatchClear(batchId, delayMs = 10000){
    setTimeout(() => {
      [...list.querySelectorAll(`li[data-batch="${batchId}"]`)].forEach(el => el.remove());
    }, delayMs);
  }

  // Full reset of input and progress (DO NOT clear the list — it will disappear by timer)
  function softResetAfterSend(){
    // clear input
    const dt = new DataTransfer();
    fileInput.files = dt.files;
    // leave progress and status: status will show "Done", hide progress
    resetProgress();
  }

  // Send files via fetch (async)
  async function sendFiles(){
    if(!fileInput.files.length){ alert('Please select files first.'); return; }
    const currentBatch = lastSelectedBatchId; // remember what exactly we send
    const addFlamegraph = flameCheckbox.checked;
    try{
      setStatus('Uploading…');
      prog.hidden = false;
      let fake = 0; const t = setInterval(()=>{fake=Math.min(99, fake+3); prog.value=fake;}, 120);

      const fd = new FormData();
      [...fileInput.files].forEach(f => fd.append('files', f, f.name));
      fd.append('addFlamegraph', addFlamegraph ? 'true' : 'false');

      const resp = await fetch(UPLOAD_URL, {method:'POST', body: fd});
      clearInterval(t); prog.value = 100;
      if(!resp.ok) throw new Error('HTTP '+resp.status);

      const result = await resp.json().catch(()=>null);
      if(!result || !result.uuid){
        setStatus('Uploaded, but the server did not return a valid uuid.');
      } else {
        applyConvertorResponse(result, {statusMessage: 'Done'});
      }

      // Do not remove current items immediately — only after 10 seconds
      scheduleBatchClear(currentBatch, 10000);
      softResetAfterSend();
    } catch(err){
      setStatus('Error: ' + err.message);
      resetProgress();
    }
  }

  // DnD events
  ['dragenter','dragover'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); e.dataTransfer.dropEffect='copy'; drop.classList.add('highlight'); })
  );
  ['dragleave','drop'].forEach(ev =>
    drop.addEventListener(ev, e => { e.preventDefault(); drop.classList.remove('highlight'); if(ev==='drop'){ setFiles(e.dataTransfer.files); }})
  );

  // Clicks and changes
  // drop.addEventListener('click', () => fileInput.click());
  pick.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => setFiles(fileInput.files));
  sendBtn.addEventListener('click', sendFiles);
  clearBtn.addEventListener('click', clearHistory);

  // Initialization
  renderHistory();
})();
</script>
<script>
const statsModal = document.getElementById('statsModal');
const closeStatsButton = document.getElementById('closeStats');

function closeStatsModal(){
  statsModal.style.display = 'none';
}

function showStatsModal(stats, uuid, statsString){
  statsModal.style.display = 'flex';
  document.getElementById('statsUuid').textContent = uuid;
  const content = statsString || (typeof stringifyStats === 'function' ? stringifyStats(stats) : JSON.stringify(stats, null, 2));
  document.getElementById('statsContent').textContent = content;
}

closeStatsButton.onclick = closeStatsModal;

document.addEventListener('keydown', (event) => {
  if(event.key === 'Escape' && statsModal.style.display !== 'none'){
    closeStatsModal();
  }
});
</script>
</body>
</html>
